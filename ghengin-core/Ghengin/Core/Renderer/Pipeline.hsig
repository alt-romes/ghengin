{-# LANGUAGE LinearTypes #-}
signature Ghengin.Core.Renderer.Pipeline where

import GHC.TypeNats
import FIR hiding (ShaderPipeline)
import FIR.Validation.Pipeline (ValidPipelineInfo)

import Ghengin.Core.Shader.Pipeline

-- other renderer details
import Ghengin.Core.Renderer.Kernel
import Ghengin.Core.Renderer.RenderPass

import Data.Counted

data GraphicsPipeline


-- import Ghengin.Vulkan.Pipeline
--     ( createGraphicsPipeline,
--       destroyPipeline,
--       PipelineConstraints,
--       VulkanPipeline )

type PipelineConstraints info top descs strides =
          ( ValidPipelineInfo info
          , '(top, descs, strides) ~ GetVertexInputInfo info
          , Known (PrimitiveTopology Nat)    top
          , Known VertexLocationDescriptions descs
          , Known BindingStrides             strides
          )

-- | Create a pipeline given a vertex shader and a fragment shader (in this
-- order)
--
-- Note that the returned vulkan pipeline must be managed in a structure that
-- ensures each pipeline renders all related items in sequence instead of
-- jumping in between pipeline
createGraphicsPipeline  :: -- (KnownDefinitions vertexdefs, KnownDefinitions fragdefs)
                        -- (CompilableProgram v, CompilableProgram f)
                        ∀  ( info    :: PipelineInfo               )
                           ( top     :: PrimitiveTopology Nat      )
                           ( descs   :: VertexLocationDescriptions )
                           ( strides :: BindingStrides             )
                           ( m       :: Type -> Type               )
                        .  PipelineConstraints info top descs strides
                        => ShaderPipeline info
                        -> RefC RenderPass -- ^ Must be reference counted since the graphics pipeline keeps an alias to it
                        -- -> V.Vector Vk.DescriptorSetLayout
                        -- -> V.Vector Vk.PushConstantRange
                         ⊸ Renderer GraphicsPipeline
