[ ] Custom lights in descriptor set #0
[ ] Should the descriptor set #0 be fixed for always needed engine data? (hardcoded) always camera position, lights positions, lights types, ...
[ ] How to specify arbitrary descriptor set #0 (pipeline global data) and descriptor set #2 data (per model data).
[ ] Free the discarded descriptor sets (or at least the mapped buffers)
[ ] Which UI changed? Currently we don't know and are simply updating all meshes the same
[ ] Array of textures for textures shared across mats?
[x] Q: Should I allocate a descriptor set per material? Is that common?
    A: Yes. It'll occupy some memory but it would require many many materials
    to ever reach the limit. It also makes things much simpler and fixes the
    mats not changing bug and the static binding design
[ ] A 'material' function to create/update? materials which allocates the descriptor set (read below)
[x] I think I can't write the same buffer in between draw calls as it seems
both will end up with the same color. It seems as if each material needs its
own descriptor set allocated and the dynamic bindings simply write the buffers
every frame, and the static bindings don't.
[ ] A function to update materials (read the one below).
[ ] A solution to update the existential materials: I think we'll have a typeable instance (like a runtime type tag) that allows us to pattern match on the type of the material to understand what kind of material it is. Then we know the type of the material and we can safely update the property value. 
[x] Compatible must ensure all required input parameters in the shader are defined in the material
[ ] Render packet data for global descriptors properties and for model descriptors properties rather than just the material properties
[x] Compatible constraint with working planets example
[x] Materials must have a compile time size to compare with the size of the descriptors defined in the shader.
[ ] Swap chain recreation...
[ ] Static bindings which simply choose the descriptor (set?) rather than write to it
[ ] Better scene graph implementation
[+] Use parent component, a cached world matrix?, and a wrapper api that threads entities ids
[ ] Textures to use with MinMax terrain height
[ ] Complete the phong model (and try some Specular lighting)
[-] Scene graph should (polymorphically?) cull the space, and
in the visible space order meshes by pipeline and material
type. Good algorithm that sorts geometry in the best possible way for the engine
[+] Free render pipelines
[y] Should each static material have its own descriptor set which simply gets bound instead of writing always over the one created with the pipeline?
[ ] Validate at compile time the meshes and materials registered for a render pipeline
[-] Scene graph (BSP, quad/octtree)
[ ] Automatically derive UISettings
[?] Disallow non-uniform scaling so that calculating the normal in world space is simpler
[+] Who's pulling in lens? Maybe I can benefit from them if I already have to have them. (Answer: fir)
[.] Bundle descriptor sets, render passes, and pipelines into a single abstraction
[ ] Toon Shader
[?] MonadRenderer to be able to call mesh creation and such from SystemT
[ ] Linear types for resource management
[+] Index buffer
[-] Since for now we decide a game can ever only use one window, we could have
    the Ghengin monad propagate the window thorought the program
